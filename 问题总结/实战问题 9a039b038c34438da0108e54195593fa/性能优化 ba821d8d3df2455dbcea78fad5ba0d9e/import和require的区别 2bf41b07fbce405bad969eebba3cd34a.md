# import和require的区别

### 一、调用时机

require: 运行时调用，理论上可以运用在代码的任何地方，

import：编译时调用，必须放在文件开头。import语句会在编译之前就执行。

### 二、打包出来的文件

懒加载：component: resolve => require(['@/view/index.vue'], resolve)

用require这种方式引入的时候，会将你的component分别打包成不同的js，加载的时候也是按需加载，只有访问这个路由网址时才会加载这个js

非懒加载：component: index

如果用import引入的话，当项目打包时路由里的所有component都会打包在一个js中，造成进入首页时，需要加载的内容过多，时间相对比较长

### 三、加载模块始的操作

require:

1. require加载模块的时候会把这个模块的代码运行一遍。
2. 如果加载的是一个基本数据类型，那么返回的是这个数据类型的浅复制。如果加载的是一个复杂的数据类型，由于浅复制的原因，两个模块引用的对象指向同一个内存空间。如果在其中一个模块中修改了值，会影响另外一个模块。
3. export这个基本类型的变量的getter就可以得到在b.js中的这个变量；同样的，如果要直接赋值修改b.js中这个变量的话，就要export这个变量的setter
4. 如果require命令加载同一个模块时，不会再次执行这个模块，而是取缓存中的值。COMMONJS的模块无论加载多少次，都只会运行一次。
    
    当一个模块被循环加载时，比如当a第二句引用b，b也引用了a。node a.js => 执行a.js => 遇到require b.js，开始执行b.js => 在b.js中遇到require a.js => 只执行a.js的第一句 => 继续执行b.js，直到结束 => 回到a.js的第二句，继续执行下面的语句。
    

import/export:

1. ES6模块加载的机制，与CommonJS模块完全不同。CommonJS模块输出的是一个值的拷贝，而ES6模块输出的是值的引用。
2. import语句会在编译之前就执行。// ??????不会执行模块，动态的只读引用，那这个编译之前就执行表示什么意思
3. es6在遇到模块加载命令import时，不会去执行模块，而是只生成一个动态的只读引用。等到真的需要用到时，再到模块里面去取值，换句话说，ES6的输入有点像Unix系统的“符号连接”，原始值变了，import输入的值也会跟着变。因此，ES6模块是动态引用，并且不会缓存值，模块里面的变量绑定其所在的模块。不同的脚本加载同一个模块得到的是同一个实例。

### 背景：

历史上，JavaScript 一直没有模块（module）体系，无法将一个大程序拆分成互相依赖的小文件，再用简单的方法拼装起来。其他语言都有这项功能，比如 Ruby 的require、Python 的import，甚至就连 CSS 都有@import，但是 JavaScript 任何这方面的支持都没有，这对开发大型的、复杂的项目形成了巨大障碍。

在 ES6 之前，社区制定了一些模块加载方案，最主要的有 CommonJS 和 AMD 两种。前者用于服务器，后者用于浏览器。ES6 在语言标准的层面上，实现了模块功能，而且实现得相当简单，完全可以取代现有的 CommonJS 和 AMD 规范，成为浏览器和服务器通用的模块解决方案。

CommonJS加载模块就是用我们熟悉的require加载模块。它的主要原理是

1. 先运行一遍要加载的模块，
2. 将输出的对象缓存到内存里，
3. 然后通过复制的方法加载到引用它的模块中。

而在ES6的规范中，定义了一种了ES6的模块，通过import/export的方式控制模块的引用和输出。