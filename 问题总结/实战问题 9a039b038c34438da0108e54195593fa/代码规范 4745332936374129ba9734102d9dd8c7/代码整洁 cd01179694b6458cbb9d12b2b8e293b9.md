# 代码整洁

组件划分、常量抽取、相同代码抽离、低耦合(不写死)、数据驱动视图

1. 组件划分
    
    组件划分的依据：按功能划分。 一般b端和c端端划分没有本质的区别，但是，
    
    -c端，不仅要实现功能，同时是严格按照ui的设计来实现的，所以可以根据ui图：抽离出每一个功能组件 + 「分析总结」出相似的页面(数据不同，页面相同)；
    
    -b端，实现功能就好，所以：按功能进行划分组件 —> 将组件之间相同的部分抽离。
    
    组件划分的简单理解：常量抽取(用全大写: const CONTENT=...)、相同代码抽离、数据抽离(指驱动视图渲染的数据)。
    
    组件的划分并不是越细致越好，因为这样可能会导致组件间传值的时候层级很深。所以，要「适合」不同的业务场景。
    
2. 低耦合
    
    开闭原则中的「扩展开放，修改关闭」。
    
    最近理解到的：所谓扩展开放，就是数据不写死，例如如下情况：
    
    ```jsx
    // ...
    <p>this is show content </p>          // 这里的p标签里的内容是写死的
    // ...
    ```
    
    再看下面这种情况：
    
    ```jsx
    // ...
    <p> {{content}} </p>
    // ...
    props: {
    	content: {
    		type: String,
    		default: 'this is show content'
    	}
    }
    ```
    
    这样，在后续修改显示内容的时候很方便，也即是所谓的数据驱动视图。
    
3. 数据驱动视图
    
    操作数据 —> 数据灌入视图 —> 视图变化
    
    所谓数据驱动视图，就是数据改变，视图改变。是一种纯函数思维：输入→输出
    
    第一步，即是将视图中的数据部分，即可变的部分抽离出来。是一种抽象的思路。视图只是数据改变后的反应(黑客帝国)。
    
    第二步，就是将大一些的视图抽离，抽成每一个小组件，即组件化(积木), 拼接的地方即是接口。需要考虑到给组件传入什么参数，组件给外部提供什么功能。
    
4. 抽象
    - 代码抽象
        
        例1:
        
        ```jsx
        // 6.9
        let params = {};
        info?.logininfo?.phone && (params = { phone: info.logininfo.phone });
        					||
        					\/
        let params = {phone: info?.logininfo?.phone || '' }
        ```
        
    - 
5. 

0. 参考：

《clean code》

[数据驱动视图](%E4%BB%A3%E7%A0%81%E6%95%B4%E6%B4%81%20cd01179694b6458cbb9d12b2b8e293b9/%E6%95%B0%E6%8D%AE%E9%A9%B1%E5%8A%A8%E8%A7%86%E5%9B%BE%20f5518b5e057543f49fb0eed412ec7b70.md)

[MVVM](%E4%BB%A3%E7%A0%81%E6%95%B4%E6%B4%81%20cd01179694b6458cbb9d12b2b8e293b9/MVVM%2098be0ac200df41079126ed6b2c1c5d81.md)